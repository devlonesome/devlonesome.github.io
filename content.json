{"pages":[{"title":"혼자 놀기의 지겨움","text":"About Me","link":"/about/index.html"}],"posts":[{"title":"Programmer Competency Matrix","text":"Source : Programmer Competency Matrix Translation : 개발자의 역량 측정 메트릭스 컴퓨터 과학 구분 레벨 0 레벨 1 레벨2 레벨3 기타 자료 구조 배열과 링크드 리스트의 차이를 모른다 배열, 링크드 리스트, Dictionaries 등을 설명하거나 실제 프로그래밍에서 사용할 수 있다 자료 구조인 배열과 링크드 리스트의 시간 대비 용량에 대한 기본적인 것을 안다 해시 테이블과 충돌 처리, 우선순위 큐 등에 대해 설명할 수 있고 구현할 수 있다 고급 자료 구조 (B-트리, binomial and fibonacci heaps, AVL/Red Black trees, Splay Trees, Skip Lists, tries 등) 에 대한 지식이 있다 알고리즘 배열의 숫자의 평균값을 찾을 수 없다 기본적인 정렬, 검색과 데이터 구조 탐색 및 탐색 알고리즘 트리, 그래프, 간단한 분할 정복 알고리즘을 이해할 수 있고 이 레벨의 다른 내용과의 연관성을 알 수 있다 동적 프로그래밍 솔루션을 이해하고 코딩할 수 있다 그래프 알고리즘에 대해서 잘 안다 수치 계산 알고리즘에 대해서 잘 안다 NP 문제를 식별할 수 있다 기타 등등 탑 수준의 코더와 함께 일한다는 건 믿을 수 없을 정도의 행운입니다 시스템 프로그래밍 컴파일러, 링커, 인터프리터가 뭔지 모른다 컴파일러와 링커, 인터프리터에 대한 기본적인 이해. 어셈블리 코드가 뭔지 이해하고 하드웨어 레벨에서 어떻게 동작하는지 안다. 가상 메모리와 페이징에 대한 약간의 지식. 커널 모드와 유저모드, 멀티 쓰레딩, synchronization primitives 들을 이해하고 있고, 어떻게 구현되었는지 알고 있으며, 어셈블리 코드를 읽을 수 있어야 한다. 네트워크가 어떻게 동작하는지 이해하고 있고, 네트워크 프로토콜과 소켓 레벨 프로그래밍에 대해서 알고 있다 전체 프로그래밍 스택과 하드웨어 (CPU+메모리+캐시+인터럽트+마이크로 코드), 바이너리 코드, 어셈블리, 정적 혹은 동적 링크, compilation, interpretaton, JIT compilation, 가비지 컬렉션, 힙, 스택, 메모리 어드레싱 등에 대해서 이해하고 있다 소프트웨어 엔지니어링 구분 레벨 0 레벨 1 레벨2 레벨3 기타 소스 코드와 버전 컨트롤 날짜 별로 폴더 백업 VSS와 CVS/SVN을 시작하는 유저 CVS와 SVN의 사용에 능숙하다 branch와 merge 등의 사용법에 대해서 안다 (본문에는 use patches setup repository properties가 포함되어 있는데 모르니 패스합니다 -_-;) 분산 VCS 시스템에 대해서 안다 Bzr/머큐리얼/Darcs/Git를 해보았다 빌드 자동화 IDE에서 빌드하는 법 밖에 모른다 커맨드 창에서 빌드하는 법을 안다 간단한 시스템을 빌드하는 스크립트를 만들 수 있다 시스템과 문서, 설치 파일, 릴리즈 문서와 소스 컨트롤의 코드 태그등을 만드는 스크립트를 만들 수 있다 테스트 자동화 테스트는 테스터가 해야 할 일이라고만 생각한다 이전의 코드에 대해서 자동 유닛 테스트를 작성해 보았다 TDD 매너에서 코드를 작성해보았다 자동화된 함수나 불러오기 성능, UI 테스트 등을 이해하고 만들 수 있다 프로그래밍 구분 레벨 0 레벨 1 레벨2 레벨3 기타 문제 파악 재사용하기 위해서 복붙하는 법밖에 모른다 여러 함수 내부에서 문제를 해결할 수 있다 재사용 가능한 함수/오브젝트를 다룰 수 있고 그와 관련된 문제들을 해결할 수 있다 적절한 데이터 구조와 알고리즘을 사용하고 뭔가 바꿔야 될 문제점을 캡슐화시키는 식의 일반적/객체지향적인 코드를 작성한다. 시스템 파악 하나의 파일/클래스를 벗어나지 못한다 같은 플랫폼/기술 내에서 문제 해결과 솔루션 디자인이 가능하다 여러 기술/플랫폼에 걸쳐서 시스템 디자인이 가능하다 다수의 제품 라인과 외부 시스템과 통합된 복잡한 시스템을 시각화 및 디자인 할 수 있다. 또한 모니터링, 보고, fail over와 같은 작업 지원 시스템을 설계할 수 있다. 커뮤니케이션 동료에게 자신의 생각이나 아이디어를 전달할 수 없다 맞춤법과 문법이 심히 좋지 않다 동료가 말한 것을 이해할 수 있다. 맞춤법과 문법이 좋다. 동료와 효율적으로 대화가 가능하다 생각/디자인/아이디어/스펙 등을 좋은 방식으로 이야기해서 이해하게 할 수 있고 상황에 따라서 대화를 조절할 수 있다 이것은 프로그램을 평가하는데 자주 사용되지만 아주 중요한 것들입니다. 영어가 모국어가 아닌 곳으로의 외주가 점점 늘어나면서 이 문제는 더 눈에 띄고 있습니다. 프로그래머가 커뮤니케이션의 의도를 알지 못해 실패한 프로젝트를 여럿 알고 있습니다 파일 내부의 코드 구조 그런거 없다 메소드가 논리적 혹은 접근성으로 그룹 지어져 있다 코드는 region에 의해 그룹화되어 있으며 다른 소스 파일에 대한 참조에 주석을 잘 달아 놓았다. 파일은 라이센스 헤더, 요약, 적절한 주석, 일괄적인 공백 사용이 잘 되어 있다. 보기에 매우 아름답다. 파일간 코드 구조 봐도 모른다 관련된 파일들은 같은 폴더 내부에 있다 각 물리적인 파일은 고유한 목적을 가지고 있다. 예를 들면 하나의 클래스 라든지 하나의 기능 구현 등 물리적 레벨에서의 코드 구성은 디자인과 일치하며 파일 이름과 폴더 분포를 보는 것으로 디자인이 무엇인지 깨달을 수 있도록 한다. 소스 트리 구조 폴더 하나에 전부 넣는다 폴더 별로 코드를 분리해 놓았다 순환 종속 없음, 바이너리, 라이브러리, 문서, 빌드, 3자 코드들이 적절한 폴더로 구성되어 있다 소스 트리의 물리적 레이아웃은 논리 계층 및 구성과 일치한다. 디렉토리 이름과 구성은 시스템의 디자인이 무엇인지 깨달을 수 있도록 한다. 앞의 항목과의 차이는 구조의 규모, 소스 시스템을 정의하는 전반적인 아티펙트들의 세트와 관련된 트리 구조이다. 코드 가독성 대충 단어 하나로 파일, 함수, 클래스, 메소드에 좋은 이름을 지어주었다 긴 함수, 묘한 코드에 대해 설명하는 주석, 버그 수정 , 가설 코드가 없다 가설 코드는 asset를 사용하여 검증되어 있다 코드는 자연스럽게 흐르며 조건문이나 메소드가 깊게 중첩되어 있지 않다 방어적 코딩 컨셉 자체를 이해를 못한다 모든 인자를 확인하고 코드의 위험한 부분에 대해서 경고한다 반환 값을 확인하고 코드에서 일어날 수 있는 전반적인 에러에 대해 검사한다 방어적 코딩을 돕고 실수를 시뮬레이팅하는 유닛 테스트를 작성하는 자신만의 라이브러리를 가지고 있다 에러 처리 잘 되기를 빈다 기본적인 에러 처리를 한다. throw exception 과 에러 생성 프로그램의 상태와 리소스, 연결이 좋고 메모리가 모두 청소되어 있다면 에러/예외 처리는 프로그램에 맡긴다 이전에 일어난 가능한 예외들을 검출하는 코드가 코드의 모든 계층에서 일괄된 예외 처리 전략을 유지하고, 전체 시스템에 대한 예외 처리 지침을 마련한다. IDE 대부분 텍스트 편집하기 위해서 사용한다 인터페이스에 대해서 알고 메뉴를 사용해서 IDE를 효율적으로 사용할 수 있다 대부분의 명령에 대한 키보드 단축키를 알고 있다 커스텀 매크로를 작성해보았다 API 자주 문서를 집중해서 봐야 한다 자주 사용하는 API를 기억하고 있다 API에 대한 광범위하고 깊은 지식 자주 사용하는 작업을 단순화하고 API의 공백을 채우기 위해서 API의 상단에 라이브러리를 작성해보았다 API의 예라면 자바 라이브러리, 닷넷 프레임워크나 애플리케이션을 위한 커스텀 API 등이 있다. 프레임워크 코어 플랫폼 외부의 프레임워크를 써본 적이 없다 들어보기는 했지만 써보지는 않았다. 전문적으로 하나 이상의 프레임워크를 사용해본 적이 있으며 프레임워크의 숙어가 익숙하다 프레임워크 저자 요구 사항 그냥 받은 대로 쓴다&lt;d/el&gt; 요구 사항에서 빠진 부분에 대한 질문을 한다 전체 그림을 이해할 수 있고 전체 부분에서 필요한 것이 무언인지 찾는다 좋은 대안을 제시할 수 있고 경험을 바탕으로 주어진 요구 사항에 맞추어 진행할 수 있다 스크립팅 스크립팅 툴 따위 모른다 batch 파일 / 셀 스크립트 펄/파이썬/루비/VB스크립트/파워쉘 재 사용 가능한 코드를 작성하고 배포해보았다 데이터베이스 액셀이 DB라는건 안다 기본적인 데이터베이스 개념, 정규화 ACID, 트랜잭션을 알고 간단한 select 를 사용할 수 있다 실행될 쿼리, 능숙한 뷰 사용, 저장 프로시져, 트리거 및 사용자 정의 유형을 염두에 두고 정규화된 좋은 데이터베이스를 디자인할 수 있다. 클러스터와 논 클러스터 인덱스간의 차이를 알고 있다. ORM 툴의 사용에 능숙하다. 기본적인 데이터베이스 관리, 성능 최적화, 인덱스 최적화, 고급 select 쿼리 작성, 관계형 sql로 커서 사용을 대체 가능, 내부 데이터 저장 방식 이해, 인덱스 내부 저장 방식 이해, 데이터베이스 미러링 혹은 복제 방법 이해 등이 가능하다. 2 단계 커밋이 어떻게 동작하는지 안다. 코드 가독성 레벨2 가설 코드 (code assumptions)해석을 어떻게 해야 될지 몰라서 저렇게 적었는데 동작이 제대로 되는지 어떤지 확인되지 않은 코드라고 이해하시면 되겠습니다 경험 구분 레벨 0 레벨 1 레벨2 레벨3 기타 전문적으로 경험한 언어 객체 지향 아니면 절차 지향 절차 지향, 객체 지향 및 선언 (SQL), static과 동적 타이핑, weak와 strong 타이핑 및 정적 추론 유형인지 함수형 프로그래밍, 느긋한 계산법, 커링, continuations을 알고 있다면 보너스 추가 Concurrent (Erlang, Oz) 와 로직 (Prolog) 전문적으로 경험해본 플랫폼 수 1 2-3 4-5 6- 전문 경험을 쌓은 연수 1 2-5 6-9 10 도메인 지식 도메인이 뭔지 잘 모른다 도메인에서 최소 하나의 제품에서 일해봤다 같은 도메인에서 여러 제품으로 작업해보았다 도메인 전문가. 도메인에서 여러 제품/솔루션을 디자인하고 구현해보았다. 도메인에서 사용하는 표준 용어, 프로토콜에 능숙하다. 함수형 프로그래밍에 대한 설명 (위키 백과) : http://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D 지식 구분 레벨 0 레벨 1 레벨2 레벨3 기타 툴 지식 주요 IDE에 대한 기초적인 것만 안다 유명한 툴의 대용품과 기본적인 툴을 알고 있다 에디터, 디버거, IDE, 대신할만한 오픈 소스 등에 대해서 잘 알고 있다. ORM 툴을 사용해보았다. 툴과 스크립트를 실제로 작성해보았다 (출시해봤다면 보너스 추가) 노출된 언어 객체 지향 아니면 절차 지향 절차 지향, 객체 지향 및 선언 (SQL), static과 동적 타이핑, weak와 strong 타이핑 및 정적 추론 유형인지 함수형 프로그래밍, 느긋한 계산법, 커링, continuations을 알고 있다면 보너스 추가 Concurrent (Erlang, Oz) 와 로직 (Prolog) 코드 베이스 지식 코드 베이스에 대해 자세히 본 적이 없다 코드 레이아웃에 대한 기본적인 지식과 시스템을 짜는 방법을 안다 코드 베이스에 대해서 잘 알고 몇 가지 버그를 수정하거나 몇몇 작은 기능을 추가해보았다 몇몇 큰 기능을 코드 베이스에 추가해보았고 주요 기능의 변경점이나 버그 픽스에 대해서 쉽게 시각화할 수 있다 차세대 기술에 대한 지식 들어본 적도 없다 현장에서 차후 사용될 기술에 대해 들어봤다 알파 프리뷰/CTP/베타를 다운로드 받아보았고, 몇몇 기사/매뉴얼을 읽어보았다 프리뷰를 돌려보았고 실제로 빌드해보았으며 다른 사람에게 그것을 공유해보았다 플랫폼 내부 그냥 모른다 플랫폼이 내부에서 어떻게 동작하는지 기본적인 건 안다 플랫폼 내부에 대해 깊게 알고 있으며 프로그램이 어떻게 돌아가는지 시각화할 수 있으며 그것을 실행 가능한 코드로 변환할 수 있다 플랫폼 내부에 대한 정보를 제공하거나 성능을 증가시키는 툴을 작성해보았다. 예를 들면 디스어셈블러, 디컴파일러, 디버거 등 책 21일 만에 배우는 xxx 같은 것들 코드 완성하기, 생각하지 않게 하기, 정규식 표현 마스터하기 디자인 패턴, peopleware, 펄 프로그래밍, 알고리즘 디자인 매뉴얼, 실용주의 프로그래머, Mythical Man month 컴퓨터 프로그램의 구조와 해석, 기술 컨셉, 컴퓨터 프로그래밍의 모델, 컴퓨터 프로그래밍 아트, 데이터베이스 시스템, Thinking Forth, Little Schemer 블로그 들어는 봤지만 할 시간은 없다 기술/프로그래밍/소프트웨어 엔지니어링 블로그를 읽고 팟캐스트를 규칙적으로 듣는다 유용한 기사와 툴을 모아 놓은 블로그를 즐겨찾기 해두었다 프로그래밍에 대한 개인적인 시각과 생각을 공유하는 블로그를 본다","link":"/2015/01/01/programmer-competency-matrix/"},{"title":"Markdown Syntax Examples","text":"GitHub Flavored Markdown[https://help.github.com/articles/writing-on-github/] @mentions, #refs, links, formatting, and tags are supported list syntax is required (any unordered or ordered list supported) this is a complete item this is an incomplete item a bigger project first subtask #1234 follow up subtask #4321 final subtask cc @mention a separate task SHA: a5c3785ed8d6a35868bc169f07e40e889087fd2e User@SHA: jlord@a5c3785ed8d6a35868bc169f07e40e889087fd2e User/Repository@SHA: jlord/sheetsee.js@a5c3785ed8d6a35868bc169f07e40e889087fd2e #Num: #26 GH-Num: GH-26 User#Num: jlord#26 User/Repository#Num: jlord/sheetsee.js#26","link":"/2015/07/01/markdown-syntax-example/"},{"title":"용어 정리","text":"첫 포스트입니다.세상은 넓고 중국인은 많고 새로운 기술은 널렸다.ㅠㅠ AWS( Amazon Web Services ) EC2 (Amazon Elastic Compute Cloud) - 가상서버 S3 (Amazon Simple Storage Service) - 인터넷 스토리지 RDS (Amazon Relational Database Service) - RDBMS Cloudfront (Amazon Cloudfront) - 콘텐츠 배포 Elastic Transcoder - 소스 형식의 미디어 파일을 스마트폰, 태블릿, PC 등의 디바이스에서 재생되는 버전으로 변환(또는 “트랜스코딩”) xDD (xxxx-Driven Development) TDD (Test-Driven Development) BDD (Behaviour-Driven Development) Rspec - BDD for Ruby Cucumber - Simple, human collaboration Code Climate - helping you diagnose and fix issues ,better code, faster","link":"/2015/07/23/aws-amazon-web-services-review/"},{"title":"SD Resize and Back up Image File on OSX","text":"라즈베리파이를 사용하다 보면 Image를 Backup/Restore 할 일이 발생한다.산딸기마을에서는 멀티제어RCCar 이미지 라던지, PiSnap 이미지라던지. 이들의 배포를 하기위해서도 Backup이 필요하다.Backup을 처음 했던 때 부터 생각했던 문제였지만, Backup된 Image의 Size는 무엇인가 불만스러움이 있었다.본인은 혹시 모를 용량 부족을 예방하기위해 32G의 SD를 사용하지만, 실제 배포를 위한 사용량은 4G에 불과하다.4G를 Restore하기 위해 32G Backup 파일을 Download/Restore 한다면, 32/4 배의 시간을 낭비하는 것.아마도 몇년간 가진 모임 참석자들은 이 문제에 대해서 불만을 토로하고 있을 것이다. Windows사용자는 Win32 Disk Imager를 사용해서 Backup/Restore를 할 것이고, OSX사용자를 위해서는 ApplePi-Baker라는 훌륭한 GUI Tool 을 사용할 것이다.또는 dd명령어도 잘 사용하여 CLI상에서 처리하는 사용자도 있을 것이다.아무튼, 몇번이고 찾고, 몇번이고 시도했지만 실패했던 문제가 아주 쉬운 방법으로 해결되었다.본격적으로 Mac OSX에서 Command 로 SD Card의 Backup image를 줄이는 방법에 대해서 알아보자.열심히 구글링 한 결과, 아래의 링크들을 통해 해결을 볼 수 있었다.http://www.htpcguides.com/easy-resize-and-back-up-raspberry-pi-sd-card-with-ubuntu/http://askubuntu.com/questions/390769/how-do-i-resize-partitions-using-command-line-without-using-a-gui-on-a-server How to on ubuntu ?ubuntu에서는 Gparted를 사용하여 GUI환경으로 resize를 해결할 수 있었다.[Easy Resize and Back up Raspberry Pi SD Card with Ubuntu][resize-sd-ubuntu-link] Install ext partition utility on OSX알다시피 라즈베리파이SD에는 두개의 partitions으로 되어있다.vfat과 ext4으로, 실제 부팅 partition인 ext4를 OSX에서 인식하기 위해서는 추가 S/W가 필요하다.이를 해결하기 위해 E2fsprogs: Ext2/3/4 Filesystem Utilities를 설치하자. 1$ brew install e2fsprogs Homebrew가 설치되지 않아 brew명령어가 깔려있지 않다면, http://brew.sh를 참고하기 바란다. Resize SD Card저장 위치를 알지 못해서 검색해보았다. 1$ sudo find / -name e2fsprogs /usr/local/opt/e2fsprogs에 설치되었으니 이동하여 확인해보자. 12345678910111213$ cd /usr/local/opt/e2fsprogs$ lsCOPYING bin libINSTALL_RECEIPT.json etc sbinREADME include share$ cd sbin$ lsbadblocks e2image fsck.ext2 mkfs.ext2 tune2fsblkid e2label fsck.ext3 mkfs.ext3 uuidddebugfs e2undo fsck.ext4 mkfs.ext4dumpe2fs filefrag fsck.ext4dev mkfs.ext4deve2freefrag findfs logsave mklost+founde2fsck fsck mke2fs resize2fs resize2fs명령어가 보인다.실행시켜보니 실행은 안되고 e2fsck -f를 실행하라고 친절하게 알려준다.순진하게 그대로 따라한다. 1$ sudo ./e2fsck -f /dev/disk2s2 /dev/disk2s2는 resize 하고자 하는 ext partition이다.라즈베리파이의 root partition을 resize하고 있는 중이다.완료되고 나서 resize2fs를 실행하자. 1$ sudo ./resize2fs /dev/disk2s2 4G partition을 4G로 resize하였다.위에 언급한 ubuntu에서는 최소 용량을 가이드해 주는데, 여기서는 알아낼 방법을 모르니 그냥 4G로 넘겨짚었다.용량을 모른다면 알고 나서 진행하도록 하자. 실제사용량 +200M 가 안전할 듯 하다.그리고, 4.2G일때는 4200M로 입력해야 된다. Backup SD Card이제 Resize 완료된 SD Card를 .img 파일로 Backup 해 보자.시간이 남아 돌거나, 해보지 않았다면 Win32 Disk Imager, ApplePi-Baker를 이용해서 Backup해 보라.SD Card 용량이 고스란히 Backup 될 것이다. 32G SD라면 .img의 용량은 32G가 될 것이고, 시간은 1시간이 걸릴지 모른다. 아래의 명령어로 Backup해 보자. OSX나 Linux등에서 사용가능한 명령어다. 1$ sudo dd if=/dev/disk2 of=/home/rasplay/raspberrypibackup.img bs=1m count=4800 이제 라즈베리파이에서 돌려보자.잘 돌아가는지 모르겠다.","link":"/2015/10/09/sd-resize-and-back-up-image-file-on-osx%20copy/"},{"title":"Node.js Compilation on Raspbian, Raspberrypi 2","text":"개인적으로 영 적응이 안되던 Node.js가 5.3.0 까지 나왔다.라즈베리파이에서 한번 써볼까 하여 compile을 해보았다. Compile 을 위한 준비Raspbian Jessie는 개인적으로 아직까지 잘 사용하지 않는다.Jessie와 Wheezy는 커널 구조상 다른지, 컴파일러 버전때문인지, 컴파일시 호환이 안되는 부분이 상당하다.이번 Node.js도 마찬가지로, Jessie에서는 되는지 모르겠으나, Wheezy에서는 컴파일이 되지 않는다.다행히 먼저 해결해논 용자가 있어 참고 하였다. ( 없었더라면 한달은 삽질을 하지 않았을까 싶다. 성공이나 했으려나…)Node.js v4 &amp; v5 on Raspberry Pi 2 gcc version을 바꾸는 일이다. /etc/apt/sources.list 파일의 Repository를 아래와 같이 수정한다. 1$ sudo nano /etc/apt/sources.list 12345678910deb http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi# Remove '#'Characterdeb http://archive.raspbian.org/raspbian wheezy main contrib non-free rpi# Source repository to adddeb-src http://archive.raspbian.org/raspbian wheezy main contrib non-free rpideb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpideb http://archive.raspbian.org/raspbian jessie main contrib non-free rpi# Source repository to adddeb-src http://archive.raspbian.org/raspbian jessie main contrib non-free rpi /etc/apt/preferences 파일을 새로 만든다. 1$ sudo nano /etc/apt/preferences 123456789Package: *Pin: release n=wheezyPin-Priority: 900Package: *Pin: release n=jessiePin-Priority: 300Package: *Pin: release o=RaspbianPin-Priority: -10 Raspbian 의 Package List를 업데이트 한다. 1$ sudo apt-get update Jessie Repositories의 gcc/g++ 4.8을 인스톨한다. 1234567$ sudo apt-get install -t jessie gcc-4.8 g++-4.8$ sudo update-alternatives --remove-all gcc$ sudo update-alternatives --remove-all g++$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.6 20$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 50$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.6 20$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 50 gcc version을 확인해보자. 1$ sudo gcc --version 혹시, gcc버전을 바꾸고 싶다면 아래와 같이 하면 된다. 12$ sudo update-alternatives --config gcc$ sudo update-alternatives --config g++ Source Downloadnodejs.org 공식홈의 Download Page에서 Source Code 주소를 얻을 수 있다. 라즈베리파이에서 아래와 같이 하여 source 파일을 download한다. 12$ wget https://nodejs.org/dist/v4.2.4/node-v4.2.4.tar.gz$ tar -xzf node-v4.2.4.tar.gz Compile &amp; Install Node.js1234$ cd node-v4.2.4$ ./configure$ make -j4$ sudo make install Node.js의 버전을 확인하여 Install이 완료되었는지 확인하자. 12$ node -v$ npm -v 다음으로는, Express도 깔고 Javascript프로젝트도 돌려보도록 하자. (언제가 될지 모르지만…)","link":"/2016/01/01/node.js-compile-on-raspbian/"},{"title":"Welcome to Jekyll!","text":"You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated. To add new posts, simply add a file in the _posts directory that follows the convention YYYY-MM-DD-name-of-post.ext and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works. Jekyll also offers powerful support for code snippets: 12345def print_hi(name) puts \"Hi, #{name}\"endprint_hi('Tom')#=&gt; prints 'Hi, Tom' to STDOUT. Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll’s dedicated Help repository.","link":"/2015/07/23/welcome-to-jekyll/"},{"title":"Machine Learning in Action - k-Nearest Neighbors","text":"k-최근접 이웃 알고리즘123장점: 높은 정확도, 오류 데이터(outlier)에 둔감, 데이터에 대한 가정이 없음단점: 계산 비용이 높음, 많은 메모리 요구적용: 수치형 값, 명목형 값","link":"/2015/10/09/machin-learning-in-action-ch2-knn/"},{"title":"About Clean Code!","text":"About Clean CodeCreate Names Sample","link":"/2015/07/24/about-clean-code/"},{"title":"Inside Javascript","text":"Javascript.멋모르고 사용 중인 언어인데 몇일전 쇼크받은 일이 있어서 다시 공부하기 시작한다.내 포스트야 항상 그렇지만 잊어먹음 대처용 포스트다. Javscript Data TypesJavascript Types 기본 타입 Number String Boolean undefined null 참조 타입 Object Array Function Regular Expression 문자열문자배열로 접근 가능 12var str = 'test';console.log(str[0]); // (output) t 문자배열로 수정은 안됨 12str[0] = 'T';console.log(str[0]); // (output) t null과 undefinednull의 type은 object 12345678910var strUnd;console.log(strUnd); // (output) undefinedconsole.log(typeof strUnd); // (output) undefinedvar strNull = null;console.log(strNull); // (output) nullconsole.log(typeof strNull);// (output) objectconsole.log(typeof strNull === null); // (output) falseconsole.log(strNull === null); // (output) true 객체 생성객체를 생성하는 세가지 방법 1231. Object() 생성자 함수 이용2. 객체 리터럴을 이용하는 방법3. 생성자 함수를 이용하는 방법 1. Object() 생성자 함수 이용 12var foo = Object();foo.name = 'foo'; 2. 객체 리터럴을 이용하는 방법 객체를 생성하는 표기법 123var foo = { name : 'foo'}; 3. 생성자 함수를 이용하는 방법 Property ControlRead Property12console.log(foo.name);console.log(foo['name']); Update Property12foo['name'] = 'newfoo';console.log(foo['name']); // (output) newfoo 대괄호 표기법만 사용해야 하는 경우12// 표현식이거나 예약어일 경우foo['full-name'] = 'foo bar'; // '-' 연산자가 포함됨 Delete property1234567console.log(foo.name); // (output) newfoodelete foo.name; // delete name propertyconsole.log(foo.name); // (output) undefinedfoo.name = 'newfoo';delete foo; // delete foo objectconsole.log(foo.name); // (output) newfoo","link":"/2016/02/02/inside-javascript/"},{"title":"Starting Docker","text":"Docker를 언급하는 곳이 몇 있길래 docker가 뭔가 하고 둘러봤는데 이게 맘에 드는 기술이다. 물론 내 현업에서는 시기상조(어쩌면 평생 이런 분야에 접근하지 않을지도.)이지만.. 이를 통해 S/W 배포가 용이해질 것 같아 조금 봐 보기로 했다. About DockerDocker를 이해하기 위해서 아래의 Site를 탐구한다. 아래의 Site를 통해 OSX용으로 인스톨 한다. Docker Official Site ‘가장 빨리 만나는 Docker’의 저자 Blog Docker의 시작Docker의 Base는 Linux Kernel이다. 때문에, Linux Kernel을 사용하는 OS는 그 자체가 DOCKER_HOST로 동작한다. Redhat, Debian … Linux Kernel을 사용하지 않는 OS는 Virtual Machine을 이용하여 Linux Kernel을 동작시킨다. 그 위에서 모든 것이 작동한다. OSX, Windows … Docker Official Site에서 알려주듯이 OSX에 Docker를 인스톨하면 모든 것이 준비되어있다. OSX에서 Docker Host에 접속하기 위해서는 아래와 같이 하면 된다. Launchpad 에서 Docker Quickstart Terminal 을 실행 열린 command 창에서 실제 실행된 명령어를 볼 수 있다. Starting Docker 사용할 Base Image 찾기 1$ docker search ubuntu Image 받기 1$ docker pull ubuntu:latest 컨테이너 생성하기 1$ docker run -i -t --name hello ubuntu /bin/bash 컨테이너 정지하기 1$ docker stop hello 정지된 컨테이너 시작하기 1$ docker start hello 컨테이너 재시작하기 1$ docker restart hello","link":"/2016/03/01/starting-docker/"},{"title":"Using Docker","text":"이번에는 Docker를 실제 사용해보자. Docker 사용 예로, Project Management application인 Redmine을 사용해보자. 간단한 Docker 설명은 이전 POST STARTING DOCKER를 참조하자. Case 1. Official InstallationDocker를 사용하기 이전에 Redmine의 초기 설치법이 어떠한지 살펴보자.Redmine Installation Guide에 따라 아래와 같이 하면 Redmine을 사용할 수 있게 된다. OS는 Unix, Linux, Mac, Windows 모두 사용 가능 Ruby가 필요함 MySQL/PostgreSQL/MSSQL/SQLite3 중 1개의 Database가 필요함 Redmine 버전에 따라 몇가지는 사용법이 다름 Installation procedure Redmine application Download Create an empty database and accompanying user Database connection configuration Dependencies installation Session store secret generation Database schema objects creation Database default data set File system permissions Test the installation Logging into the application 약 15단계를 거쳐, (말이 15 단계지 그 안에 들어가면 각각 3-5 명령어는 있으니…) Redmine을 설치할 수 있었다. Case 2. Using Docker이제 Docker를 사용해보자. 이전 포스트를 참고하여 필요한 사항만 나열하였다. 123456$ docker search redmineNAME DESCRIPTION STARS OFFICIAL AUTOMATEDsameersbn/redmine 175 [OK]redmine Redmine is a flexible project 122 [OK]bitnami/redmine Bitnami Docker Image f 3 [OK]74th/redmine-all-in-one Redmine includes hosting S 2 [OK] OFFICIAL이 [OK] 되어있는 버전을 사용해보자. 12$ docker pull redmine$ docker run redmine http://192.168.99.100:3000/ 로 접속해보자. 무엇인가 로그가 막 나오지만 Web으로 접속 할 수는 없다. container 내에서의 port가 막혀있기 때문이다. 몇가지 옵션을 줘서 해결해보자. 1$ docker run -d --name redmine_container -p 3000:3000 redmine 이제 다시 http://192.168.99.100:3000/ 로 접속해보자. Redmine 초기 화면을 볼 수 있을 것이다. 이렇게 Docker를 사용하면, 기존의 능력자들이 build 해논 Docker Image를 가지고 손쉽고 빠르게 Application을 사용할 수 있다. 현업에서도 충분히 배포용도로 사용이 가능하다고 많은 이들이 말하고 있다. 위의 Redmine은 Docker Container의 특성상 Data는 휘발성으로 Container가 지워지는 시점에 Data가 지워진다. 이를 해결하기 위해서는 DB Container를 별도로 두고, Data Directory를 별도로 두어 link해서 사용하면 된다. Constainer가 지워진 상태이더라도 Data는 보존될 것이다. 이는 Docker Hub에 가서 Redmine Image 페이지를 참고하자.","link":"/2016/03/05/using-docker/"},{"title":"github.io with hexo","text":"github.io 블로깅을 위해 github.io 호스팅을 사용합니다. Hexo backend는 hexo를 사용합니다. hexo는 node.js입니다. 또다른 정적blog 호스팅 툴인 jekyll은 ruby n rails입니다. Source와 Publish의 분리 Blog 내용은 Markdown문서로 정리합니다. Hexo 서버로 local에서 확인 후 github.io로 deploy합니다. github.io에는 html 형식으로 저장됩니다.(Markdown이 저장되지 않습니다.) 사용법Hexo 환경설정node.js, npm 및 hexo를 설치합니다.hexo.io 링크를 참조합니다. 12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 문서 추가 및 배포 문서 추가 1$ hexo new [layout] &lt;title&gt; 정적파일 생성 1$ hexo generate 배포 1$ hexo deploy devlonesome.github.io 예제 Hexo 설치 1$ npm install 포스트 추가 1$ hexo new post \"Test New Post\" Hexo Post 확인 1$ hexo server 1http://localhost:4000 정적파일 생성 1$ hexo generate 배포 1$ hexo deploy","link":"/2020/03/07/github-io-with-hexo/"},{"title":"markdown-syntax-example","text":"@mentions, #refs, links, formatting, and tags are supported list syntax is required (any unordered or ordered list supported) this is a complete item this is an incomplete item a bigger project first subtask #1234 follow up subtask #4321 final subtask cc @mention a separate task SHA: a5c3785ed8d6a35868bc169f07e40e889087fd2e User@SHA: jlord@a5c3785ed8d6a35868bc169f07e40e889087fd2e User/Repository@SHA: jlord/sheetsee.js@a5c3785ed8d6a35868bc169f07e40e889087fd2e #Num: #26 GH-Num: GH-26 User#Num: jlord#26 User/Repository#Num: jlord/sheetsee.js#26","link":"/2020/03/07/markdown-syntax-example/"},{"title":"Sublime Text 사용","text":"Download Sublime Text 3https://www.sublimetext.com/3 Package ControlSublime Text 를 사용하는 이유는 다양한 플러그인 패키지를 마음데로 사용할 수 있기 때문이다.이를 사용하기 위해 Package Control을 준비해야 한다. Installation https://packagecontrol.io/installation ctrl+` 단축키를 사용하거나, View &gt; Show Console 메뉴를 선택한다. Sublime Text 아래에 편집창이 나타나면 아래의 text를 붙여넣기 하고 실행한다. 1import urllib.request,os,hashlib;h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) Sublime Text를 재시작한다. [Package] File Browser사이드바에 File Tree를 보여주고 File Browser 역할을 하는 Package이다. Installation https://github.com/aziz/SublimeFileBrowser cmd+shift+p 단축키를 사용하여 Package Control을 실행시킨다. Install Package로 검색하고 실행한다. FileBrowser로 검색하고 설치한다. Preferences &gt; Package Settings &gt; File Browser &gt; Key Bindings &gt; User를 선택하고 다음을 추가하면, f1단축키로 File Browser를 실행할 수 있다. 12345678910{ &quot;keys&quot;: [&quot;f1&quot;], &quot;command&quot;: &quot;dired&quot;, &quot;args&quot;: { &quot;immediate&quot;: true, &quot;single_pane&quot;: true, &quot;other_group&quot;: &quot;left&quot;, &quot;project&quot;: true }}","link":"/2020/03/07/2016-2-20-IDEs-Sublime-Text/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/07/hello-world/"}],"tags":[{"name":"programmer, study","slug":"programmer-study","link":"/tags/programmer-study/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"front-end, javascript","slug":"front-end-javascript","link":"/tags/front-end-javascript/"},{"name":"devops, docker","slug":"devops-docker","link":"/tags/devops-docker/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"IDE, Text Editor, Sublime Text","slug":"IDE-Text-Editor-Sublime-Text","link":"/tags/IDE-Text-Editor-Sublime-Text/"}],"categories":[{"name":"programmer","slug":"programmer","link":"/categories/programmer/"},{"name":"Software Basic","slug":"Software-Basic","link":"/categories/Software-Basic/"},{"name":"servers","slug":"servers","link":"/categories/servers/"},{"name":"jekyll update","slug":"jekyll-update","link":"/categories/jekyll-update/"},{"name":"machinelearning","slug":"machinelearning","link":"/categories/machinelearning/"},{"name":"front-end","slug":"front-end","link":"/categories/front-end/"},{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"IDE","slug":"IDE","link":"/categories/IDE/"}]}